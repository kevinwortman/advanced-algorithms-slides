
\documentclass{beamer}

\usepackage{algpseudocode, color, colortbl, listings, MnSymbol}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    urlcolor=blue,
}

\usetheme{Montpellier}
\usecolortheme{rose}

% page numbers, from
% https://tex.stackexchange.com/questions/137022/how-to-insert-page-number-in-beamer-navigation-symbols
\expandafter\def\expandafter\insertshorttitle\expandafter{%
  \insertshorttitle\hfill%
  \insertframenumber\,/\,\inserttotalframenumber}

\definecolor{Gray}{gray}{0.8}
\newcolumntype{g}{>{\columncolor{Gray}}c}

\newcommand{\stanza}{ \\~\ }

\title{11. Computational Geometry and Convex Hulls}
\subtitle{CPSC 535 $\sim$ Spring 2019}
\author{Kevin A. Wortman}
\institute{ \includegraphics[height=2cm]{csuf-logo-cmyk} }
\date{November 18, 2019 \stanza

\includegraphics[height=14pt]{by} \\

{\tiny
This work is licensed under a
\href{http://creativecommons.org/licenses/by/4.0/}{Creative Commons Attribution 4.0 International License}.
}}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame} \frametitle{Big Idea: Output Sensitive Algorithm}
  \begin{itemize}
    \item \textbf{input sensitive}: time efficiency is a function of the input
      e.g. size $n$, \# edges $m$
    \item \textbf{output sensitive}: efficiency is also a function of the
      \emph{output} size e.g. \# items returned
    \item most relevant when the size of the output could be the
      bottleneck
  \end{itemize}
\end{frame}

\begin{frame} \frametitle{Computational Geometry}
\textbf{computational $X$}: interdisciplinary study of computer science with $X$ \\
(computational sociology/epidemiology/physics/finance/etc.) \stanza

computational geometry (CG): algorithms, data structures, asymptotic analysis, of
geometric objects: points, lines, circles, triangle meshes, etc. \stanza

Applications
\begin{itemize}
  \item computer graphics, user interfaces
  \item GIS, geographic databases
  \item scene reconstruction (e.g. LIDAR)
  \item business operations research (e.g. linear programming, aircraft control)
  \item manufacturing (e.g. feasibility of assembly, castings)
\end{itemize}
\end{frame}

\begin{frame} \frametitle{Putting the Geo in CG}
Some general algorithms can actually solve geometric problems efficiently, without
any awareness of the geometry. \stanza

\emph{bounding box problem} \\
\textbf{input}: set of 2D points $P=\{p_1, p_2, \ldots, p_n\}$ \\
\textbf{output}: points $tl=(x_l, y_t)$ and $rb=(x_r, y_b)$ such that the rectangle
with top-left corner $tl$ and bottom-right corner $rb$ contains $P$ \stanza

Na\"{i}ve, optimal algorithm: $x_l, y_t, x_r, y_b = $ min $x$, min $y$, max $x$,
max $y$ respectively; $\Theta(n)$ \stanza

Computational geometers are most interested when geometric properties matter.
\end{frame}

\begin{frame} \frametitle{Line Segment Predicates}
We can use arithmetic to answer any of the following predicates (questions)
about points $p_0, p_1, p_2, p_3$ in $\Theta(1)$ time:
\begin{enumerate}
  \item Is line segment $\overline{p_0 p_1}$ clockwise from $\overline{p_0 p_2}$
    around the common endpoint $p_0$?
  \item If we follow $\overline{p_0 p_1}$ and then $\overline{p_1 p_2}$, do we
    turn right or left?
  \item Do line segments $\overline{p_0 p_1}$ and $\overline{p_2 p_3}$
    intersect?
\end{enumerate}

$\implies$ We may use any of these in pseudocode.
\end{frame}

\begin{frame} \frametitle{Degeneracy and Non-Degeneracy Assumptions}
\textbf{degenerate} object: has the proper shape/type, but the values are a
  special case that betrays the spirit of the definition \stanza

\emph{Example:} triangle $\equiv$ three points $(p_1, p_2, p_3)$ \\
degenerate triangle: $p_1=p_2=p_3$; or $p_1, p_2, p_3$ colinear; etc. \stanza

\textbf{Non-degeneracy assumption}:
\begin{itemize}
  \item constraint that input to a CG algorithm is not degenerate in specific ways
  \item simplifies algorithm design
  \item assume that in practice, some combination of
  \begin{itemize}
    \item degeneracies do not occur
    \item input can be preprocessed to remove degeneracies
    \item implementer can modify algorithm to handle degeneracies
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame} \frametitle{Sweep Algorithms}
A pattern in CG algorithms:
\begin{itemize}
  \item \emph{line sweep:} envision a line ``sweeping'' through the input
  \item e.g. a vertical line sweeping left-to-right
  \item helps us visualize a 2D situation as a 1D situation that changes over
    time
  \item like duality, doesn't actually change the problem, but might help us
    problem-solve
  \item generalizes to higher dimensions e.g. plane sweep in 3D, hyperplane sweep
    in any dimension
\end{itemize}
\end{frame}

\begin{frame} \frametitle{Convex Hulls}
\emph{convex hull problem} \\
\textbf{input}: set of $n \geq 3$ points $Q$ \\
\textbf{output}: $CH(Q)$, the subset of $Q$ that is the set of vertices on
  the convex hull of $Q$ \stanza

Convex hull $\equiv$ boundary of convex polygon enclosing all of $Q$ \stanza

Applications
\begin{itemize}
  \item object intersection in raytracing, video games, GUIs
  \item drawing implicit regions in GIS
  \item finding farthest points
  \item component of other algorithms
\end{itemize}
\end{frame}

\begin{frame} \frametitle{Approaches to Convex Hulls}
Like the sorting problem, many algorithm patterns work for convex hulls,
and there is a rich literature of competitive algorithms. \stanza

\begin{itemize}
  \item Greedy pattern: line-sweep, update hull as we go
  \item Divide-and-conquer: divide $Q$ in half, compute convex hulls for each
    half, merge two convex hulls into one
  \item Iterative improvement: start with a superset of $CH(Q)$; refine by repeatedly eliminating
    a constant fraction of the points until only $CH(Q)$ remains
\end{itemize}
\end{frame}

\begin{frame} \frametitle{Baseline Algorithm}
\textbf{Observe}
\begin{itemize}
  \item any two input points define a line $\ell$
  \item when those points are both in $CH(Q),$ remaining $n-2$ points are all on
    the same side of $\ell$ \emph{(geometric property)}
  \item $\implies$ for each pair of input points $p, q$, see whether all other points
    are on the same side of $\ell$
  \item if so include $p, q$ in $CH(Q)$
\end{itemize}
\end{frame}

\begin{frame} \frametitle{Baseline Pseudocode}
  {\small
\begin{algorithmic}[1]
  \Function{NAIVE-CONVEX-HULL}{$Q$}
    \State $H=\emptyset$
    \For { distinct points $p, q \in Q$ }
      \State form line $\ell$ intersecting $p$ and $q$
      \State $k = $ \# points above $\ell$
      \If { $k=(n-2)$ or $k=0$ }
        \State $H = H \cup \{p, q\}$
      \EndIf
    \EndFor
    \State \Return $H$
  \EndFunction
\end{algorithmic}
}

\textbf{Analysis}: $\Theta(n^3)$ time
\end{frame}

\begin{frame} \frametitle{Graham Scan Idea}
\begin{itemize}
  \item greedy pattern, reduction-to-sorting
  \item Heuristic: when touring the hull in counter-clockwise order, we
    \textbf{only make left turns}
  \item right turn $=$ exiting a concavity; middle point not in hull
  \item $\therefore$ sweep counter-clockwise, keep points that participate in left
    turns, drop points in the middle of right turns
  \item alternative kind of line sweep: rotating the line (not left-to-right)
\end{itemize}
\end{frame}

\begin{frame} \frametitle{Graham Scan Greedy Heuristic}
\begin{itemize}
  \item $p_1, \ldots, p_m = Q$ sorted into counter-clockwise order, eliminating ties
  \item stack $S$ of points; contains hull of points visited \emph{already}
  \item base case: push first 3 points onto $S$
  \begin{itemize}
    \item for any three points $p, q, r$ forming a non-degenerate triangle,
      $CH(\{p, q, r\}) = \{p, q, r\}$
    \end{itemize}
  \item inductive case:
    \begin{itemize}
      \item examine next input point $p_i$, top of stack $t$, next-lowest stack point $r$
      \item if $\angle r t p_i$ is not a left turn $\implies t$ not on hull
    \end{itemize}
  \item Note: need stack data structure w/ accessor to top \textbf{two} elements
  \end{itemize}
\end{frame}

\begin{frame} \frametitle{Graham Scan Pseudocode}
  {\small
\begin{algorithmic}[1]
  \Function{GRAHAM-SCAN}{$Q$} \Comment{guaranteed $|Q| \geq 3$}
    \State $p_0 = $ lowest point in $Q$ (break ties by choosing leftmost point)
    \State $p_1 \ldots p_m = $ sort $Q-\{p_0\}$ into counter-clockwise order,
      by polar angle with $p_0$; break ties by keeping only the point farthest from $p_0$
    \State $S$ = new stack
    \State $S.PUSH(p0)$
    \State $S.PUSH(p1)$
    \State $S.PUSH(p2)$
    \For { $i$ from $3$ through $m$ }
      \While { $\angle p_i, S.TOP, S.BELOWTOP$ is non-left turn }
        \State $S.POP()$
      \EndWhile
      \State $S.PUSH(p_i)$
    \EndFor
    \State \Return $S$
  \EndFunction
\end{algorithmic}
}
\end{frame}

\begin{frame} \frametitle{Graham Scan Analysis}
\begin{itemize}
  \item find $p_0$: $\Theta(n)$
  \item sort: $\Theta(n \log n)$
  \item eliminate tied points: $\Theta(n)$
  \item each stack operation is $\Theta(1)$
  \item \textbf{for} loop repeats $m < n$ times
  \item turn angle test, stack operations are $\Theta(1)$
  \item $\Rightarrow \Theta(n \log n)$ time
  \item dominating term is sort, organizing data structure is arrayed stack
    $\Rightarrow$ good constant factors
\end{itemize}
\end{frame}

\begin{frame} \frametitle{Jarvis March}
\textbf{Alternative greedy heuristic}: moving around the hull counter-clockwise,
 each step from one vertex to the next is
 \emph{the input point whose angle is shallowest} (``gift wrapping'') \stanza

Jarvis march
\begin{enumerate}
  \item Find the lowest and highest points in $Q$.
  \item (right chain) Starting from the lowest point, and until we reach the highest point:
    \begin{enumerate}
      \item Linear search $Q$ for the next point, minimizing the angle between
        the two points.
      \item Add the first point to $CH(Q)$ and move to the second point.
    \end{enumerate}
  \item (left chain) Starting from the highest point, repeat this process until we
    reach the lowest point.
  \item Return $CH(Q)$
\end{enumerate}
\end{frame}

\begin{frame} \frametitle{Jarvis March Analysis}
  Preprocessing to find highest/lowest: $\Theta(n)$ \stanza

  Each iteration of the left/right-chain loops identifies one hull point \\
  $\implies$ in total they iterate $h$ times,
  where $h \equiv $ number of points on the hull. \stanza

  linear search inside the loops takes $\Theta(n)$ time. \stanza

  $\therefore$ $\Theta(nh)$ total time. \stanza

  Faster than Graham scan's $\Theta(n \log n)$ when $h \in o(\log n).$ \stanza

  \textbf{Optimal output-sensitive}: Chan's algorithm, $\Theta(n \log h)$.
\end{frame}

\begin{frame} \frametitle{Summary of Convex Hull Algorithms}
\begin{center}
  \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Algorithm} & \textbf{Time} & \textbf{Main Idea} \\ \hline
    Graham Scan & $\Theta(n \log n)$ & sort, skip right turns \\
    Jarvis March & $\Theta(nh)$ & gift-wrapping \\
    Chan's algorithm & $\Theta(n \log h)$ & divide w/ Graham, merge w/ Jarvis \\
    \hline
  \end{tabular}
\end{center}
\end{frame}

\end{document}
