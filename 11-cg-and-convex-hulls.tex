
\documentclass{beamer}

\usepackage{algpseudocode, color, colortbl, listings, MnSymbol}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    urlcolor=blue,
}

\usetheme{Montpellier}
\usecolortheme{rose}

% page numbers, from
% https://tex.stackexchange.com/questions/137022/how-to-insert-page-number-in-beamer-navigation-symbols
\expandafter\def\expandafter\insertshorttitle\expandafter{%
  \insertshorttitle\hfill%
  \insertframenumber\,/\,\inserttotalframenumber}

\definecolor{Gray}{gray}{0.8}
\newcolumntype{g}{>{\columncolor{Gray}}c}

\newcommand{\stanza}{ \\~\ }

\title{11. Computational Geometry and Convex Hulls}
\subtitle{CPSC 535 $\sim$ Spring 2019}
\author{Kevin A. Wortman}
\institute{ \includegraphics[height=2cm]{csuf-logo-cmyk} }
\date{November 18, 2019 \stanza

\includegraphics[height=14pt]{by} \\

{\tiny
This work is licensed under a
\href{http://creativecommons.org/licenses/by/4.0/}{Creative Commons Attribution 4.0 International License}.
}}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame} \frametitle{Convex Hulls}
\emph{convex hull problem} \\
\textbf{input}: set of $n \geq 3$ points $Q$ \\
\textbf{output}: $CH(Q)$, the subset of $Q$ that is the set of vertices on
  the convex hull of $Q$ \stanza

Convex hull $\equiv$ boundary of convex polygon enclosing all of $Q$ \stanza

Applications
\begin{itemize}
  \item object intersection in raytracing, video games, GUIs
  \item drawing implicit regions in GIS
  \item finding farthest points
  \item component of other algorithms
\end{itemize}
\end{frame}

\begin{frame} \frametitle{Approaches to Convex Hulls}
Like the sorting problem, many algorithm patterns work for convex hulls,
and there is a rich literature of competitive algorithms. \stanza

\begin{itemize}
  \item Greedy pattern: line-sweep, update hull as we go
  \item Divide-and-conquer: divide $Q$ in half, compute convex hulls for each
    half, merge two convex hulls into one
  \item Iterative improvement: start with a superset of $CH(Q)$; refine by repeatedly eliminating
    a constant fraction of the points until only $CH(Q)$ remains
\end{itemize}
\end{frame}

\begin{frame} \frametitle{Baseline Algorithm}
\textbf{Observe}
\begin{itemize}
  \item any two input points define a line $\ell$
  \item when those points are both in $CH(Q),$ remaining $n-2$ points are all on
    the same side of $\ell$ \emph{(geometric property)}
  \item $\implies$ for each pair of input points $p, q$, see whether all other points
    are on the same side of $\ell$
  \item if so include $p, q$ in $CH(Q)$
\end{itemize}
\end{frame}

\begin{frame} \frametitle{Baseline Pseudocode}
  {\small
\begin{algorithmic}[1]
  \Function{NAIVE-CONVEX-HULL}{$Q$}
    \State $H=\emptyset$
    \For { distinct points $p, q \in Q$ }
      \State form line $\ell$ intersecting $p$ and $q$
      \State $k = $ \# points above $\ell$
      \If { $k=(n-2)$ or $k=0$ }
        \State $H = H \cup \{p, q\}$
      \EndIf
    \EndFor
    \State \Return $H$
  \EndFunction
\end{algorithmic}
}

\textbf{Analysis}: $\Theta(n^3)$ time
\end{frame}

\begin{frame} \frametitle{Graham Scan Idea}
\begin{itemize}
  \item greedy pattern, reduction-to-sorting
  \item Heuristic: when touring the hull in counter-clockwise order, we
    \textbf{only make left turns}
  \item right turn $=$ exiting a concavity; middle point not in hull
  \item $\therefore$ sweep counter-clockwise, keep points that participate in left
    turns, drop points in the middle of right turns
  \item alternative kind of line sweep: rotating the line (not left-to-right)
\end{itemize}
\end{frame}

\begin{frame} \frametitle{Graham Scan Greedy Heuristic}
\begin{itemize}
  \item $p_1, \ldots, p_m = Q$ sorted into counter-clockwise order, eliminating ties
  \item stack $S$ of points; contains hull of points visited \emph{already}
  \item base case: push first 3 points onto $S$
  \begin{itemize}
    \item for any three points $p, q, r$ forming a non-degenerate triangle,
      $CH(\{p, q, r\}) = \{p, q, r\}$
    \end{itemize}
  \item inductive case:
    \begin{itemize}
      \item examine next input point $p_i$, top of stack $t$, next-lowest stack point $r$
      \item if $\angle r t p_i$ is not a left turn $\implies t$ not on hull
    \end{itemize}
  \item Note: need stack data structure w/ accessor to top \textbf{two} elements
  \end{itemize}
\end{frame}

\begin{frame} \frametitle{Graham Scan Pseudocode}
  {\small
\begin{algorithmic}[1]
  \Function{GRAHAM-SCAN}{$Q$} \Comment{guaranteed $|Q| \geq 3$}
    \State $p_0 = $ lowest point in $Q$ (break ties by choosing leftmost point)
    \State $p_1 \ldots p_m = $ sort $Q-\{p_0\}$ into counter-clockwise order,
      by polar angle with $p_0$; break ties by keeping only the point farthest from $p_0$
    \State $S$ = new stack
    \State $S.PUSH(p0)$
    \State $S.PUSH(p1)$
    \State $S.PUSH(p2)$
    \For { $i$ from $3$ through $m$ }
      \While { $\angle p_i, S.TOP, S.BELOWTOP$ is non-left turn }
        \State $S.POP()$
      \EndWhile
      \State $S.PUSH(p_i)$
    \EndFor
    \State \Return $S$
  \EndFunction
\end{algorithmic}
}
\end{frame}

\begin{frame} \frametitle{Graham Scan Analysis}
\begin{itemize}
  \item find $p_0$: $\Theta(n)$
  \item sort: $\Theta(n \log n)$
  \item eliminate tied points: $\Theta(n)$
  \item each stack operation is $\Theta(1)$
  \item \textbf{for} loop repeats $m < n$ times
  \item turn angle test, stack operations are $\Theta(1)$
  \item $\Rightarrow \Theta(n \log n)$ time
  \item dominating term is sort, organizing data structure is arrayed stack
    $\Rightarrow$ good constant factors
\end{itemize}
\end{frame}

\begin{frame} \frametitle{Jarvis March}
\textbf{Alternative greedy heuristic}: moving around the hull counter-clockwise,
 each step from one vertex to the next is
 \emph{the input point whose angle is shallowest} (``gift wrapping'') \stanza

Jarvis march
\begin{enumerate}
  \item Find the lowest and highest points in $Q$.
  \item (right chain) Starting from the lowest point, and until we reach the highest point:
    \begin{enumerate}
      \item Linear search $Q$ for the next point, minimizing the angle between
        the two points.
      \item Add the first point to $CH(Q)$ and move to the second point.
    \end{enumerate}
  \item (left chain) Starting from the highest point, repeat this process until we
    reach the lowest point.
  \item Return $CH(Q)$
\end{enumerate}
\end{frame}

\begin{frame} \frametitle{Jarvis March Analysis}
  Preprocessing to find highest/lowest: $\Theta(n)$ \stanza

  Each iteration of the left/right-chain loops identifies one hull point \\
  $\implies$ in total they iterate $h$ times,
  where $h \equiv $ number of points on the hull. \stanza

  linear search inside the loops takes $\Theta(n)$ time. \stanza

  $\therefore$ $\Theta(nh)$ total time. \stanza

  Faster than Graham scan's $\Theta(n \log n)$ when $h \in o(\log n).$ \stanza

  \textbf{Optimal output-sensitive}: Chan's algorithm, $\Theta(n \log h)$.
\end{frame}

\begin{frame} \frametitle{Summary of Convex Hull Algorithms}
\begin{center}
  \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Algorithm} & \textbf{Time} & \textbf{Main Idea} \\ \hline
    Graham Scan & $\Theta(n \log n)$ & sort, skip right turns \\
    Jarvis March & $\Theta(nh)$ & gift-wrapping \\
    Chan's algorithm & $\Theta(n \log h)$ & divide w/ Graham, merge w/ Jarvis \\
    \hline
  \end{tabular}
\end{center}
\end{frame}

\end{document}
